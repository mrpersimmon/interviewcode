package nowcoder.twopointers;

/**
 * 思路：
 * 如果是已经排好序的数组，如果可以使用新的辅助数组，那很容易借助归并排序的思想，将两个已经排好序的子数组合并在一起。
 * 但是，这道题要求我们在数组 A 上添加，因为数组 A 后半部分相当于为空。
 * 可以考虑逆向使用归并排序思想，从较大的开始排。
 * 对于两个数组，每次选取较大的值，因此需要使用两个同时向前遍历的双指针。
 */
public class BM87_MergeTwoArray {

    public void merge(int[] A, int m, int[] B, int n) {
        // 1. 使用三个指针
        int i = m - 1; // 指向数组 A 的结尾
        int j = n - 1; // 指向数组 B 的结尾
        int k = m + n - 1; // 指向数组 A 空间的结尾处

        // 2. 从两个数组最大元素开始遍历，直到某一个结束，
        //    每次取出较大的一个值放入到数组 A 空间的最后，然后指针依次往前

        while (i >= 0 && j >= 0) { // 从两个数组最大的元素开始遍历，直到某一个数组遍历完
            // 将较大的元素放到最后
            if (A[i] > B[j]) {
                A[k] = A[i];
                k--;
                i--;
            } else {
                A[k] = B[j];
                k--;
                j--;
            }
        }
        // 3. 如果数组 A 先遍历结束，需要把数组 B 剩余的前半部分依次逆序加入数组 A 前半部分，
        //    类似归并排序最后步骤；
        //    如果数组 B 先遍历结束，数组 A 前半部分已经存在了，就不用管了。

        if (i < 0) { // 数组 A 已经遍历完了，数组 B 还有，则需要添加到数组 A 前面
            while (j >= 0) {
                A[k] = B[j];
                k--;
                j--;
            }
        }
        // 数组 B 遍历完成，数组 A 前面正好有，不用再添加了
    }
}
